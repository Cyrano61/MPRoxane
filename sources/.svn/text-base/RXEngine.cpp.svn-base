/*
 *  RXEngine.cpp
 *  BitBoard
 *
 *  Created by Bruno Causse on 10/08/05.
 *  Copyright 2005 personnel. All rights reserved.
 *
 */
#include <iomanip>
#include <cmath>
#include <fstream>
#include <sstream>


#include "RXEngine.h"
#include "RXTimer.h"
#include "RXRoxane.h"

const int RXEngine::CHECK_TO_LAST_THREE = 4; // DO NOT CHANGE

const int RXEngine::NO_CUT = 0;
const int RXEngine::ALPHA_CUT = 1;
const int RXEngine::BETA_CUT = 2;

const int RXEngine::HASHTABLE = 0;
const int RXEngine::INFERIOR = 1;
const int RXEngine::EXACT = 2;
const int RXEngine::SUPERIOR = 3;
const int RXEngine::INTERRUPT = 4;
const int RXEngine::GGS_MSG = 5;

const int RXEngine::CONFIDENCE[] = {72, 84, 91, 95, 98, 100};
const int RXEngine::NO_SELECT = 5;
const int RXEngine::DEPTH_BOOSTER = 4;


std::vector< std::vector< std::vector<int> > > RXEngine::midcut_coeff;
std::vector< std::vector<int> > RXEngine::endcut_coeff;

extern "C"
void* init_thread(void* pt)  {
	
	RXEngine* engine = (RXEngine*)(pt);
	
	engine->idle_loop();
	
	return NULL;
	
}


void RXEngine::load_probcut_coeff() {

/*
int newCoeff[24];
	newCoeff[0]  = 680; //12
	newCoeff[1]  = 672; //13
	newCoeff[2]  = 665; //14
	newCoeff[3]  = 657; //15
	newCoeff[4]  = 649; //16
	newCoeff[5]  = 630; //17
	newCoeff[6]  = 600; //18
	newCoeff[7]  = 567; //19 **
	newCoeff[8]  = 537; //20
	newCoeff[9]  = 510; //21
	newCoeff[10] = 480; //22
	newCoeff[11] = 448; //23
	newCoeff[12] = 417; //24
	newCoeff[13] = 387; //25
	newCoeff[14] = 358; //26
	newCoeff[15] = 331; //27
	newCoeff[16] = 310; //28
	newCoeff[17] = 295; //29
	newCoeff[18] = 275; //30
	newCoeff[19] = 260; //31
	newCoeff[20] = 248; //32
	newCoeff[21] = 243; //33
	newCoeff[22] = 240; //34

	std::ofstream to("../XEndCut3.bin", std::ios::binary);
	if(to) {
		
		int s[] = {0};
		for(int iStage = 48; iStage >=26; iStage--) { //[34;12] empties
			s[0] = newCoeff[48 - iStage];
			to.write((char*)s, sizeof(int));

		}
			
		to.close();
	}
*/

	const float MG_percentile[] = {1.1f, 1.2f, 1.3f, 1.5f, 2.0f};

	const float EG_percentile[] = {1.1f, 1.40f, 1.85f, 2.30f, 3.40f}; //new
	//const float EG_percentile[] = {1.1f, 1.4f, 1.7f, 2.0f, 3.0f};
	
	//initialisation midcut_coeff
	midcut_coeff.resize(61);
	for(int iStage = 0; iStage<61; iStage++) {
		//int n_depth_pair = (20 < 53-iStage? 20 : 53-iStage);
		int n_depth_pair = (25 < 53-iStage? 25 : 53-iStage);
		if(n_depth_pair>0) {
			midcut_coeff[iStage].resize(n_depth_pair);
			for(int iDepth_pair = 0; iDepth_pair<n_depth_pair; iDepth_pair++) {
				midcut_coeff[iStage][iDepth_pair].resize(MG_LOW_SELECT+1);
				for(int selectivity = MG_HIGH_SELECT; selectivity <= MG_LOW_SELECT; selectivity++)
					midcut_coeff[iStage][iDepth_pair][selectivity] = MAX_SCORE;
			}
		}
	}
	
	std::ifstream from("../XProbcuti386.bin", std::ios::binary); //Edmond
	if(from) {
		
		float s[] = {0};			
							
		for(int iStage = 16; iStage<53; iStage++) {
			//int n_depth_pair = (20 < 53-iStage? 20 : 53-iStage);
			int n_depth_pair = (25 < 53-iStage? 25 : 53-iStage);
			for(int iDepth_pair = 0; iDepth_pair<n_depth_pair; iDepth_pair++) {
				from.read((char*)s, sizeof(float));
				for(int selectivity = MG_HIGH_SELECT; selectivity <= MG_LOW_SELECT; selectivity++)
					midcut_coeff[iStage][iDepth_pair][selectivity] =  static_cast<int>(round(MG_percentile[selectivity]*s[0]));
			}
		}
			
		from.close();
	}

/*
	//print midcut_coeff
	for(int iStage = 16; iStage<53; iStage++) {
		//int n_depth_pair = (20 < 53-iStage? 20 : 53-iStage);
		int n_depth_pair = (25 < 53-iStage? 25 : 53-iStage);
		for(int iDepth_pair = 0; iDepth_pair<n_depth_pair; iDepth_pair++) {
			std::cout	<< "stage : " << std::setw(2) << iStage 
						<< " check_depth : " << std::setw(2) <<iDepth_pair
						<< " " << std::setw(5) << midcut_coeff[iStage][iDepth_pair][0]
						<< std::endl;
		}
	}
*/
	
	//initialistion endcut_coeff
	endcut_coeff.resize(61);
	for(int iStage = 0; iStage<61; iStage++) {
		endcut_coeff[iStage].resize(NO_SELECT);
		for(int selectivity = EG_LOW_SELECT; selectivity<NO_SELECT; selectivity++)
			endcut_coeff[iStage][selectivity] = MAX_SCORE;
	}

	std::ifstream from_1("../XEndCuti386.bin", std::ios::binary); //Edmond
	if(from_1) {
		
		int s[] = {0};
		for(int iStage = 48; iStage >=26; iStage--) { //[34;12] empties
			from_1.read((char*)s, sizeof(int));

			for(int selectivity = EG_LOW_SELECT; selectivity<NO_SELECT; selectivity++)
				endcut_coeff[iStage][selectivity] =  static_cast<int>(round(EG_percentile[selectivity]*s[0]));
		}
			
		from_1.close();
	}

/*	
	//print endcut_coeff
	for(int iStage = 48; iStage >=26; iStage--) { //[34;12] empties						
		for(int selectivity = EG_LOW_SELECT; selectivity<NO_SELECT; selectivity++)
			std::cout	<< "stage : " << std::setw(2) << iStage 
						<< " selectivity : " << std::setw(2) << selectivity
						<< " " << std::setw(5) << endcut_coeff[iStage][selectivity]
						<< std::endl;
	}

*/ 	
	
		
	
}


//int RXEngine::MPC_check(RXBBPatterns& sBoard, const int depth, int alpha_check, int beta_check, RXMove* list, const bool hashMove) {
int RXEngine::MPC_check(int threadID, const bool endgame, RXBBPatterns& sBoard, const int depth, const int alpha_check, const int beta_check, RXMove* list, const bool hashMove) {

	RXBitBoard& board = sBoard.board;
	
	
	int static_eval = sBoard.get_score();
	
	RXMove* list1 = list;

	int bestscore = UNDEF_SCORE;
	if(hashMove) {
		list1 = list1->next;
		
		((sBoard).*(sBoard.update_patterns[list1->position][board.player]))(*list1);
		
		if(static_eval>alpha_check) {
			sBoard.do_move(*list1);
			
			if(depth == 2) {
			
				RXMove& lastMove = threads[threadID]._move[board.n_empties][1];
				
				int bestscore_1 = UNDEF_SCORE;
				const unsigned long long discs_opponent = board.discs[board.player^1];
				for(RXSquareList* empties = board.empties_list->next; bestscore_1 < (-beta_check+1) && empties->position != NOMOVE; empties = empties->next)
					if ((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((sBoard).*(sBoard.generate_patterns[empties->position][board.player]))(lastMove)) {

						board.n_nodes++;

						int score= -sBoard.get_score(lastMove);
						if (score>bestscore_1)
							bestscore_1 = score;

					}

				if(bestscore_1 == UNDEF_SCORE) {		//PASS
					bestscore_1 = sBoard.get_score();
				}
				
				bestscore = -bestscore_1;
				
			} else if(depth == 3) {
				bestscore = -alphabeta_last_two_ply(threadID, sBoard, -beta_check, -beta_check+1, false);
			} else if(depth == 4) {
				bestscore = -PVS_last_three_ply(threadID, sBoard, -beta_check, -beta_check+1, false);
			} else {
				bestscore = -PVS_check(threadID, sBoard, depth-1, -beta_check, -beta_check+1, false);
			}
			
			sBoard.undo_move(*list1);
			
			if(bestscore >= beta_check) { //beta cut
				hTable->update(board.hash_code, type_hashtable, NO_SELECT, depth, beta_check, bestscore, list1->position);
				return BETA_CUT;
			}
		}
		
	}
	
	//sort moves list
	if(list1->next != NULL) {
	
		RXMove* iter = list1->next;
		
		if(iter->next != NULL) {

			const int p = board.player;
			const int o = p^1;

			if(depth>3) {
		
				int alpha_threshold = -MAX_SCORE;
				int beta_threshold  =  MAX_SCORE;
				MG_get_cut_bounds(board.n_empties, 0, 4, 0, alpha_threshold, beta_threshold);
								
				if((alpha_check+alpha_threshold)<= static_eval) { //~95%

					RXMove& lastMove = threads[threadID]._move[board.n_empties-1][1];
			
					for(; iter != NULL; iter = iter->next) {
						((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
						
						sBoard.do_move(*iter);
						
						if(depth>9) {
						
							iter->score += PVS_last_three_ply(threadID, sBoard, -MAX_SCORE, -(alpha_check+alpha_threshold), false);//*2

						} if(depth>6) {
						
							iter->score += alphabeta_last_two_ply(threadID, sBoard, -MAX_SCORE, -(alpha_check+alpha_threshold), false);//*2
				
						} else {
						
							int bestscore = UNDEF_SCORE; //masquage
							const unsigned long long discs_opponent = board.discs[board.player^1];
							for(RXSquareList* empties = board.empties_list->next;bestscore < -(alpha_check+alpha_threshold) && empties->position != NOMOVE; empties = empties->next) { //*2
								if ((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((sBoard).*(sBoard.generate_patterns[empties->position][board.player]))(lastMove)) {
									board.n_nodes++;

									int score = -sBoard.get_score(lastMove);	
									if (score>bestscore) {
										bestscore = score;
									}
												 
								}
							}
							
							
							if(bestscore == UNDEF_SCORE) {  //PASS
								iter->score += sBoard.get_score();
							} else {
								iter->score += bestscore;
							}
							
						}


						if(iter->score < -(beta_check+beta_threshold)) { //95%
							if(endgame)
								iter->score /= 4; //16
							iter->score -= MAX_SCORE; //good move	"probable beta cut"	study in first
						}
						
						if(endgame)
							iter->score += board.get_mobility(board.discs[board.player], board.discs[board.player^1])*VALUE_DISC - (board.get_corner_stability(board.discs[board.player^1])*VALUE_DISC)/16;
						
						sBoard.undo_move(*iter);

					}

		
				} else {
				

					for(; iter != NULL; iter = iter->next) {
						board.n_nodes++;
						
						((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
						iter->score += sBoard.get_score(*iter);
						
						if(endgame) {
							
							const unsigned long long p_discs = board.discs[p] | (iter->flipped | iter->square);
																					
							iter->score += 2*(RXBitBoard::get_mobility(board.discs[o] ^ iter->flipped, p_discs)*VALUE_DISC) - (RXBitBoard::get_corner_stability(p_discs)*VALUE_DISC)/8;

						}
						
						
					}
				}
				
			} else {
		
				for(; iter != NULL; iter = iter->next) {
					board.n_nodes++;
					
					((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
					iter->score += sBoard.get_score(*iter);
					
					if(endgame) {
						
						const unsigned long long p_discs = board.discs[p] | (iter->flipped | iter->square);
																				
						iter->score += 2*(RXBitBoard::get_mobility(board.discs[o] ^ iter->flipped, p_discs)*VALUE_DISC) - (RXBitBoard::get_corner_stability(p_discs)*VALUE_DISC)/8;

					}
				}
			}

			list1->sort_by_score();

		} else {
			((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
		}

	}
	

	if(static_eval>alpha_check) {
	
		//beta prob cut
		for(RXMove* iter = list1->next; iter != NULL; iter = iter->next) {
			
			sBoard.do_move(*iter);
			
			if(depth == 2) {
				RXMove& lastMove = threads[threadID]._move[board.n_empties][1];
			
				int bestscore_1 = UNDEF_SCORE;
				
				const unsigned long long discs_opponent = board.discs[board.player^1];
				for(RXSquareList* empties = board.empties_list->next; bestscore_1 < (-beta_check+1) && empties->position != NOMOVE; empties = empties->next)
					if ((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((sBoard).*(sBoard.generate_patterns[empties->position][board.player]))(lastMove)) {
						board.n_nodes++;


						int score= -sBoard.get_score(lastMove);
						if (score> bestscore_1) {
							bestscore_1 = score;
						}
						

					}

				if(bestscore_1 == UNDEF_SCORE) {		//PASS
					bestscore_1 = sBoard.get_score();
				}
				
				bestscore = -bestscore_1;
				
			} else if(depth == 3) {
				bestscore = -alphabeta_last_two_ply(threadID, sBoard, -beta_check, -beta_check+1, false);
			} else if(depth == 4) {
				bestscore = -PVS_last_three_ply(threadID, sBoard, -beta_check, -beta_check+1, false);
			} else {
				bestscore = -PVS_check(threadID, sBoard, depth-1, -beta_check, -beta_check+1, false);
			}
			
			sBoard.undo_move(*iter);
			
			if(bestscore >= beta_check) { //beta cut
				hTable->update(board.hash_code, type_hashtable, NO_SELECT, depth, beta_check, bestscore, iter->position);
				return BETA_CUT;
			}
			
		}
	}
	
	//alpha prob cut
	
	bestscore = UNDEF_SCORE;
	int bestmove = list->next->position;
	
	if(static_eval<beta_check) {

		if(hashMove) {
			list = list->next;
			
			sBoard.do_move(*list);
			
			if(depth == 2) {
			
				RXMove& lastMove = threads[threadID]._move[board.n_empties][1];
				
				int bestscore_1 = UNDEF_SCORE;
				
				const unsigned long long discs_opponent = board.discs[board.player^1];
				for(RXSquareList* empties = board.empties_list->next; bestscore_1 < -alpha_check && empties->position != NOMOVE; empties = empties->next)
					if ((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((sBoard).*(sBoard.generate_patterns[empties->position][board.player]))(lastMove)) {
						board.n_nodes++;

						
						int score= -sBoard.get_score(lastMove);
						if (score>bestscore_1) {
							bestscore_1 = score;
						}
						

					}

				if(bestscore_1 == UNDEF_SCORE) {		//PASS
					bestscore_1 = sBoard.get_score();
				}
				
				bestscore = -bestscore_1;
				
			} else if(depth == 3) {
				bestscore = -alphabeta_last_two_ply(threadID, sBoard, -alpha_check-1, -alpha_check, false);
			} else if(depth == 4) {
				bestscore = -PVS_last_three_ply(threadID, sBoard, -alpha_check-1, -alpha_check, false);
			} else {
				bestscore = -PVS_check(threadID, sBoard, depth-1, -alpha_check-1, -alpha_check, false);
			}
			
			sBoard.undo_move(*list);
			
			if(bestscore>alpha_check) { //alpha cut
				hTable->update(board.hash_code, type_hashtable, NO_SELECT, depth, alpha_check, bestscore, list->position);
				return NO_CUT;
			}
			
		}

		RXMove* previous = list;
		for(RXMove* iter = list->next; iter != NULL;) {
			
			sBoard.do_move(*iter);
			
			if(depth == 2) {
			
				RXMove& lastMove = threads[threadID]._move[board.n_empties][1];
				
				int bestscore_1 = UNDEF_SCORE;
				
				const unsigned long long discs_opponent = board.discs[board.player^1];
				for(RXSquareList* empties = board.empties_list->next; bestscore_1 < -alpha_check && empties->position != NOMOVE; empties = empties->next)
					if ((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((sBoard).*(sBoard.generate_patterns[empties->position][board.player]))(lastMove)) {
						board.n_nodes++;


						int score= -sBoard.get_score(lastMove);
						if (score>bestscore_1) {
							bestscore_1 = score;
						}


					}

				if(bestscore_1 == UNDEF_SCORE) {		//PASS
					bestscore_1 = sBoard.get_score();
				}
				
				iter->score = -bestscore_1;
				
			} else if(depth == 3) {
				iter->score = -alphabeta_last_two_ply(threadID, sBoard, -alpha_check-1, -alpha_check, false);
			} else if(depth == 4) {
				iter->score = -PVS_last_three_ply(threadID, sBoard, -alpha_check-1, -alpha_check, false);
			} else {
				iter->score = -PVS_check(threadID, sBoard, depth-1, -alpha_check-1, -alpha_check, false);
			}
			
			sBoard.undo_move(*iter);
			

			if (iter->score > bestscore) {
				bestmove = iter->position;
				bestscore = iter->score;
			}
			

			if(iter->score <= alpha_check) { //alpha cut
							
				//sort list
				bool sort = false;	
				for(RXMove* previousInsert = list; previousInsert->next != iter; previousInsert = previousInsert->next)
					if(iter->score<previousInsert->next->score) {
						previous->next = iter->next;
						iter->next = previousInsert->next;
						previousInsert->next = iter;
						sort = true;
						break;
					}
				
							
				if(sort)	
					iter = previous->next;
				else
					iter = (previous = iter)->next;
					
			} else {
				
				previous->next = iter->next;
				iter->next = list->next;
				list->next = iter;
				break;
			}
				
		}
		
		hTable->update(board.hash_code, type_hashtable, NO_SELECT, depth, alpha_check, bestscore, bestmove);
		
		if(bestscore <= alpha_check)
			return ALPHA_CUT;
	}
	
	return NO_CUT;
	
}


int RXEngine::PVS_check(int threadID, RXBBPatterns& sBoard, int depth, int alpha, int beta, bool passed) {

	RXBitBoard& board = sBoard.board;

	int bestmove = NOMOVE;
	int hashmove = NOMOVE;
		
	int upper = beta;
	int lower = alpha;
	
	//synchronized access
	RXHash entry;
	if(hTable_shallow->get_sync(board, entry)) {
		if(entry.depth >= depth) {
		
			if (upper > entry.upper) {
				upper = entry.upper;
				if (upper <= lower)
					return upper;
			}
			
			if (lower < entry.lower) {
				lower = entry.lower;
				if (lower >= upper)
					return lower;
			}
		
		}
		
		hashmove = entry.move;
	}

	
	int bestscore = UNDEF_SCORE;
		
	if(hashmove != PASS) {

		RXMove* list = threads[threadID]._move[board.n_empties];
		int n_moves = 0;

		if(hashmove != NOMOVE) {

			RXMove& move = list[1];
			((board).*(board.generate_move[hashmove]))(move);
			((sBoard).*(sBoard.update_patterns[hashmove][board.player]))(move);

			//first move
			sBoard.do_move(move);
			if(depth == CHECK_TO_LAST_THREE)
				bestscore = -PVS_last_three_ply(threadID, sBoard, -upper, -lower, false);
			else
				bestscore = -PVS_check(threadID, sBoard, depth-1, -upper, -lower, false);
			sBoard.undo_move(move);

			bestmove = hashmove;

			if(bestscore>lower)
				lower = bestscore;
		}

		
		if(lower < upper ) {

			
			if(bestmove != NOMOVE) {
				RXSquareList* empty = board.position_to_empties[bestmove];
				empty->previous->next = empty->next;
				n_moves = board.moves_producing(list);
				empty->previous->next = empty;
			} else {
				n_moves = board.moves_producing(list);
			}
			
			if(n_moves != 0) {

				RXMove* iter = list->next;
			
				if(n_moves > 1) {
				
					if(depth>5) {
				
						int alpha_threshold = -MAX_SCORE;
						int beta_threshold  =  MAX_SCORE;
						MG_get_cut_bounds(board.n_empties, 0, 4, 0, alpha_threshold, beta_threshold); //72%
						
						int eval_position = sBoard.get_score();
						
						if((lower+alpha_threshold*2)<= eval_position) { //~95%

							RXMove& lastMove = threads[threadID]._move[board.n_empties-1][1];
					
							for(; iter != NULL; iter = iter->next) {
								((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
								
								sBoard.do_move(*iter);

								if(depth>9) {
								
									iter->score = alphabeta_last_two_ply(threadID, sBoard, -MAX_SCORE, -(lower+alpha_threshold*2), false);
						
								} else {
								
									int bestscore = UNDEF_SCORE; //masquage
									const unsigned long long discs_opponent = board.discs[board.player^1];
									for(RXSquareList* empties = board.empties_list->next; bestscore < -(lower+alpha_threshold*2) && empties->position != NOMOVE; empties = empties->next) {
										if ((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((sBoard).*(sBoard.generate_patterns[empties->position][board.player]))(lastMove)) {
											board.n_nodes++;

											int score = -sBoard.get_score(lastMove);	
											if (score>bestscore) {
												bestscore = score;
											}
														 
										}
									}
									
									
									if(bestscore == UNDEF_SCORE) {  //PASS
										iter->score = sBoard.get_score();
									} else {
										iter->score = bestscore;
									}
									
								}
								
								sBoard.undo_move(*iter);

							}

				
						} else {
						
							for(; iter != NULL; iter = iter->next) {
								((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
						
								board.n_nodes++;
								iter->score = sBoard.get_score(*iter);
							}
						}
						
					} else {
					
						for(; iter != NULL; iter = iter->next) {
							((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
					
							board.n_nodes++;
							iter->score = sBoard.get_score(*iter);
						}
					}
					
				} else {
					((sBoard).*(sBoard.update_patterns[iter->position][board.player]))(*iter);
				}
				

				if(bestmove == NOMOVE) {

					RXMove* previous_move = list;
					RXMove* move = previous_move->next;
					
					RXMove* previous_iter = move;
					for(RXMove* iter = previous_iter->next ; iter != NULL; iter = (previous_iter = iter)->next) {
						if(iter->score < move->score) {
							move = iter;
							previous_move = previous_iter;
						}
					}
	
					if(previous_move != list) {
						//move to front
						previous_move->next = move->next;
						move->next = list->next;
						list->next = move;
					}
					
					sBoard.do_move(*move);
					if(depth == CHECK_TO_LAST_THREE)
						bestscore = -PVS_last_three_ply(threadID, sBoard, -upper, -lower, false);
					else
						bestscore = -PVS_check(threadID, sBoard, depth-1, -upper, -lower, false);
					sBoard.undo_move(*move);

					bestmove = move->position;
					if(bestscore>lower)
						lower = bestscore;
						
					// next move
					list = list->next;
				}

				//other moves
				int score = UNDEF_SCORE;
				for(; lower < upper && list->next != NULL; list = list->next) {

					
					RXMove* previous_move = list;
					RXMove* move = previous_move->next;
					
					RXMove* previous_iter = move;
					for(RXMove* iter = previous_iter->next ; iter != NULL; iter = (previous_iter = iter)->next) {
						if(iter->score < move->score) {
							move = iter;
							previous_move = previous_iter;
						}
					}
					
					if(previous_move != list) {
						//move to front
						previous_move->next = move->next;
						move->next = list->next;
						list->next = move;
					}
			
					sBoard.do_move(*move);
			
					if(depth == CHECK_TO_LAST_THREE) {
						score = -PVS_last_three_ply(threadID, sBoard, -lower-1, -lower, false);
						if(lower < score && score < upper)
							score = -PVS_last_three_ply(threadID, sBoard, -upper, -score, false);
					} else {
						score = -PVS_check(threadID, sBoard, depth-1, -lower-1, -lower, false);
						if(lower < score && score < upper)
							score = -PVS_check(threadID, sBoard, depth-1, -upper, -score, false);
					}
			
					sBoard.undo_move(*move);
			
					if(score>bestscore) {
						bestscore = score;
						bestmove = move->position;
						if(bestscore>lower)
							lower = bestscore;
					}
				}
			}
		}
	}
	
	if(bestscore == UNDEF_SCORE) {
	
		if(passed) {
			board.n_nodes--;
			alpha = -MAX_SCORE;
			beta = MAX_SCORE;
			bestmove = NOMOVE;
			bestscore = sBoard.final_score();
		} else {
			board.n_nodes++;
			board.do_pass();
			if(depth == CHECK_TO_LAST_THREE)
				bestscore = -PVS_last_three_ply(threadID, sBoard, -upper, -lower, true);
			else
				bestscore = -PVS_check(threadID, sBoard, depth-1, -upper, -lower, true);
			board.do_pass();
			bestmove = PASS;
		}
	}
			
	hTable_shallow->update(board.hash_code, depth, alpha, beta, bestscore, bestmove);
	
	return bestscore;
					
}




int RXEngine::PVS_last_three_ply(int threadID, RXBBPatterns& sBoard, int alpha, int beta, bool passed) {

	RXBitBoard& board = sBoard.board;

	int bestmove = NOMOVE;
	int hashmove = NOMOVE;
		
	int upper = beta;
	int lower = alpha;

	//synchronized access
	RXHash entry;
	if (hTable_shallow->get_sync(board, entry)) {
		if(entry.depth >= 3) {
			
			if (upper > entry.upper) {
				upper = entry.upper;
				if (upper <= lower)
					return upper;
			}
			
			if (lower < entry.lower) {
				lower = entry.lower;
				if (lower >= upper)
					return lower;
			}
			
		}
		
		hashmove = entry.move;
	}
	
	int bestscore = UNDEF_SCORE;
	
	if (hashmove != PASS) {
		
		RXMove& move = threads[threadID]._move[board.n_empties][1];
		RXSquareList* empties = board.empties_list->next;

		const unsigned long long discs_opponent = board.discs[board.player^1];

		//fisrt move
		if(hashmove != NOMOVE) {
			
			bestmove = hashmove;
			((board).*(board.generate_move[bestmove]))(move);
			((sBoard).*(sBoard.update_patterns[bestmove][board.player]))(move);
			
			sBoard.do_move(move);
			bestscore = -alphabeta_last_two_ply(threadID, sBoard, -upper, -lower, false);
			sBoard.undo_move(move);
			
			if(bestscore>lower)
				lower = bestscore;
				
		} else {

			do {
				if((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((board).*(board.generate_move[empties->position]))(move)) {
					((sBoard).*(sBoard.update_patterns[move.position][board.player]))(move);
					
					sBoard.do_move(move);
					bestscore = -alphabeta_last_two_ply(threadID, sBoard, -upper, -lower, false);
					sBoard.undo_move(move);

					bestmove = empties->position;
					if(bestscore>lower)
						lower = bestscore;
					
				}
				
				empties = empties->next;

			} while(bestscore == UNDEF_SCORE && empties->position != NOMOVE);
		}
		
		//other moves
		int score = UNDEF_SCORE;
		for(; lower<upper && empties->position != NOMOVE; empties = empties->next) {
			if(empties->position != hashmove && (discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((board).*(board.generate_move[empties->position]))(move)) {
				((sBoard).*(sBoard.update_patterns[move.position][board.player]))(move);
			
				sBoard.do_move(move);
				score = -alphabeta_last_two_ply(threadID, sBoard, -lower-1, -lower, false);
				if(lower < score && score < upper)
					score = -alphabeta_last_two_ply(threadID, sBoard, -upper, -score, false);

				sBoard.undo_move(move);

				if(score>bestscore) {
					bestscore = score;
					bestmove = empties->position;
					if(bestscore>lower)
						lower = bestscore;

				}
			}
		
		}
	} 

	if(bestscore == UNDEF_SCORE) {

		if(passed) {
			board.n_nodes--;
			alpha = -MAX_SCORE;
			beta = MAX_SCORE;
			bestmove = NOMOVE;
			bestscore = sBoard.final_score();
		} else {
			board.n_nodes++;
			board.do_pass();
			bestscore = -alphabeta_last_two_ply(threadID, sBoard, -upper, -lower, true);
			board.do_pass();
			bestmove = PASS;
		}
	}
		
	hTable_shallow->update(board.hash_code, 3, alpha, beta, bestscore, bestmove);
	
	return bestscore;
						
}



int RXEngine::alphabeta_last_two_ply(int threadID, RXBBPatterns& sBoard, int alpha, int beta, bool passed) {
	
	RXBitBoard& board = sBoard.board;

	int bestscore = UNDEF_SCORE;
	
	RXMove& move = threads[threadID]._move[board.n_empties][1];
	RXMove& lastmove = threads[threadID]._move[board.n_empties - 1][1];
		
				
	//other moves
	const unsigned long long discs_opponent = board.discs[board.player^1]; 
	for(RXSquareList* empties = board.empties_list->next; empties->position != NOMOVE; empties = empties->next) {
		if((discs_opponent & RXBitBoard::NEIGHBOR[empties->position]) && ((board).*(board.generate_flips[empties->position]))(move)) {
			
			((sBoard).*(sBoard.update_patterns[empties->position][board.player]))(move);
			
			int opponent = board.player ^ 1;
		
			board.discs[board.player] |= (move.flipped | move.square);
			board.discs[opponent] ^= move.flipped;
		
			board.n_empties--;
		
			board.n_nodes++;
			board.player = opponent;
			
			empties->previous->next = empties->next;
			
					
			sBoard.pattern = move.pattern;
			
			/***************************************************************************************************/
			/* Last ply                                                                                         /
			/***************************************************************************************************/
			int bestscore_1 = UNDEF_SCORE;
			const unsigned long long discs_opponent_1 = board.discs[board.player^1]; 
			for(RXSquareList* empties_1 = board.empties_list->next; bestscore_1 < -alpha && empties_1->position != NOMOVE; empties_1 = empties_1->next) {
				if((discs_opponent_1 & RXBitBoard::NEIGHBOR[empties_1->position]) && ((sBoard).*(sBoard.generate_patterns[empties_1->position][board.player]))(lastmove)) {
					board.n_nodes++;
						
					int score = -sBoard.get_score(lastmove);
					if(score>bestscore_1) {
						bestscore_1 = score;
					}
				}
			}
				
			if(bestscore_1 == UNDEF_SCORE) {		//PASS
				bestscore_1 = sBoard.get_score();
			}
			/***************************************************************************************************/
				
			int score = -bestscore_1;
			
			opponent = board.player ^ 1;

			sBoard.pattern = move.undo_pattern;
				
			empties->previous->next = empties;

			board.n_empties++;
				
			board.discs[opponent] ^= (move.flipped | move.square);
			board.discs[board.player] |= move.flipped;

			board.player = opponent;
			
			if(score>=beta)
				return score;
					
			if(score>bestscore) {
				bestscore = score;
				if(bestscore>alpha)
					alpha = bestscore;
			}
		}
	}
	
	if(bestscore == UNDEF_SCORE) {	//PASS
		
		if(passed) {
			board.n_nodes--;
			bestscore = sBoard.final_score();
		} else {
			board.n_nodes++;
			
			board.player ^=1;
			/***************************************************************************************************/
			/* Last ply                                                                                         /
			/***************************************************************************************************/
			int bestscore_1 = UNDEF_SCORE;
			const unsigned long long discs_opponent_1 = board.discs[board.player^1]; 

			for(RXSquareList* empties_1 = board.empties_list->next; bestscore_1 < -alpha && empties_1->position != NOMOVE; empties_1 = empties_1->next) {
				if((discs_opponent_1 & RXBitBoard::NEIGHBOR[empties_1->position]) && ((sBoard).*(sBoard.generate_patterns[empties_1->position][board.player]))(lastmove)) {
					board.n_nodes++;
					
					int score = -sBoard.get_score(lastmove);
					if(score>bestscore_1)
						bestscore_1 = score;
				}
			}
			
			if(bestscore_1 == UNDEF_SCORE) {		//PASS
				board.n_nodes--;
				bestscore_1 = sBoard.final_score();
			}
			/***************************************************************************************************/
			bestscore = -bestscore_1;
			
			board.player^=1;
		}
	}
			
	
	return bestscore;

}

std::string RXEngine::variationPrincipal(RXBitBoard& board, int depth) const {
	return hTable->line2String(board, depth, type_hashtable);
}

std::string RXEngine::showPV(RXBitBoard& board, int depthLine) const {
	std::ostringstream buffer;

	// unsynchronized acces
	const RXHash* entry = hTable->get(board, type_hashtable);
	if(entry != NULL) {

		int depth = static_cast<int>(entry->depth);
		if(depth>board.n_empties)
			depth = board.n_empties;
			
		buffer << " " << depth << "@" << CONFIDENCE[entry->selectivity];

		bool pv_ext = false;
		if(depth!=board.n_empties && depth>RXEngine::MIN_DEPTH_USE_PV_EXTENSION && depth+RXEngine::PV_EXTENSION_DEPTH>=board.n_empties)
			if(entry->lower == entry->upper && entry->lower%VALUE_DISC == 0) {
				pv_ext = true;
			} else if(entry->lower == -MAX_SCORE &&  entry->upper%VALUE_DISC == 0) {
				pv_ext = true;
			} else if(entry->lower%VALUE_DISC == 0) {
				pv_ext = true;
			}
		
		if( entry->selectivity != NO_SELECT)
			buffer <<  (pv_ext? "+":" ");

		buffer << "  " << RXMove::index_to_coord(entry->move);
		
		int score;
		if(entry->lower == entry->upper) {
			buffer << " == ";
			score = entry->lower;
		} else if(entry->lower == -MAX_SCORE) {
			buffer << " <= ";
			score = entry->upper;
		} else {
			buffer << " >= ";
			score = entry->lower;
		}
				
		buffer << std::fixed << std::showpos << std::setprecision(2) << ((float)score)/VALUE_DISC;

		buffer << "  Pv : " << hTable->line2String(board, depthLine, type_hashtable);
	}
	
	return buffer.str();
	
}

std::string RXEngine::showHashmove(const RXBitBoard& board, const RXHash* entry) const {

	std::ostringstream buffer;
	
	int depth = static_cast<int>(entry->depth);
	if(depth>board.n_empties)
		depth = board.n_empties;
		
	buffer << "[" << depth << "@" << CONFIDENCE[entry->selectivity];
		
	bool pv_ext = false;
	if(depth!=board.n_empties && depth>RXEngine::MIN_DEPTH_USE_PV_EXTENSION && depth+RXEngine::PV_EXTENSION_DEPTH>=board.n_empties)
		if(entry->lower == entry->upper && entry->lower%VALUE_DISC == 0) {
			pv_ext = true;
		} else if(entry->lower == -MAX_SCORE &&  entry->upper%VALUE_DISC == 0) {
			pv_ext = true;
		} else if(entry->lower%VALUE_DISC == 0) {
			pv_ext = true;
		}
	
	if( entry->selectivity != NO_SELECT)
		buffer <<  (pv_ext? "+":" ");
	
	buffer << "] " << RXMove::index_to_coord(entry->move);
	
	int score;
	if(entry->lower == entry->upper) {
		buffer << " == ";
		score = entry->lower;
	} else if(entry->lower == -MAX_SCORE) {
		buffer << " <= ";
		score = entry->upper;
	} else {
		buffer << " >= ";
		score = entry->lower;
	}
			
	buffer << std::fixed << std::showpos << std::setprecision(2) << ((float)score)/VALUE_DISC;
	

	return buffer.str();

}

std::string RXEngine::showBestmove(const int depth, const bool pv_ext, const int selectivity, const int alpha, const int beta, const int score, const int bestmove) const {

	std::ostringstream buffer;
		
	buffer << " " << depth << "@" << CONFIDENCE[selectivity];
	
	if( selectivity != NO_SELECT)
		buffer << (pv_ext? "+":" ");

		
	buffer << "  " << RXMove::index_to_coord(bestmove);
	
	if(score<=alpha)
		buffer << " <= ";
	else if (beta <= score)
		buffer << " >= ";
	else
		buffer << " == ";
		
	buffer << std::fixed << std::showpos << std::setprecision(2) << ((float)score)/VALUE_DISC;
	

	return buffer.str();

}

std::string RXEngine::display(RXBitBoard& board, const int type, const int allowed_display, int score, const double time, const double time_level) {

	std::ostringstream buffer;
	
	//unsynchronized acces
	const RXHash* entry = hTable->get(board, type_hashtable);
	if(entry != NULL && ((entry->depth >= board.n_empties && entry->selectivity >= allowed_display) || (entry->depth < board.n_empties && entry->depth >= allowed_display))) {
		
		
		buffer << (type == HASHTABLE? "[":" ");
		buffer <<std::fixed << std::setw(2) << (entry->depth >= board.n_empties? board.n_empties : entry->depth);
		if(entry->selectivity != NO_SELECT)
			buffer << "@" << std::setw(2) << CONFIDENCE[entry->selectivity];
		else
			buffer << "   ";
			
		buffer << (type == HASHTABLE? "]|":" |");
		
		int _type = type;
		
		if(type == HASHTABLE || type == GGS_MSG) {
			if(entry->upper == entry->lower) {
				score = entry->upper;
				_type = EXACT;
			} else if(entry->upper == MAX_SCORE) {
				score = entry->lower;
				_type = SUPERIOR;
			} else {
				score = entry->upper;
				_type = INFERIOR;
			}
		}
				
			
		if(entry->depth < board.n_empties) { //midGame
			if(score >= MAX_SCORE-64*VALUE_DISC)
				score -= MAX_SCORE+64*VALUE_DISC;
			else if (score <= -MAX_SCORE+64*VALUE_DISC)
				score += MAX_SCORE-64*VALUE_DISC;
		}
	
		switch(_type) {
			case INFERIOR:
				buffer << "<=";
				break;
			case SUPERIOR:
				buffer << ">=";
				break;
			case INTERRUPT:
				buffer << " #";
				break;
			default:
				buffer << "  ";
				break;
		}
		
		buffer << std::showpos << std::setprecision(2) << std::setw(6) << (float)score/VALUE_DISC << " | ";
		
		buffer << std::noshowpos << variationPrincipal(board, 12) << "| ";
		
		if(type != GGS_MSG) {
			if(type == HASHTABLE) {
				buffer << "00:00:00.00 |            |            |";
			} else {
				buffer << RXTimer::toHMS(time) << " | ";
				
				buffer << std::noshowpos << std::setprecision(0) << std::setw(10) << board.n_nodes << " | ";
				
				buffer << std::setw(10) << board.n_nodes/time_level << " |";
			}
		}
				
	}
	
	return buffer.str();
	
}

void RXEngine::set_priority() {

	condition.lock_mutex();
	if(!priority) {
		priority = true;
		condition.signal();
	}
	condition.unlock_mutex();
}

//synchronized method
void RXEngine::wait() {

	mutex.lock();

	condition.lock_mutex();
	priority = false;
	condition.unlock_mutex();

	mutex.unlock();

}


void RXEngine::stop() {

	if(process != NULL) {
		set_priority();
		abortSearch = true;
		process->join();
		delete process;
		process = NULL;
	}

	hash_code_search = 0;
	
	
}


void RXEngine::resume() {

	set_priority();

	resume_mutex.lock();
	resume_flag = true;
	resume_mutex.unlock();
	
	/*
	if(process != NULL)
		abortSearch = true;
	*/
	
	//modif 28/09/2008
	//wait stop engine?
	if(process != NULL) {
		abortSearch = true;
		process->join();
		delete process;
		process = NULL;
	}
	
	hash_code_search = 0;
	hTable_shallow->reset();
}


//synchronized method
void RXEngine::get_move(RXBBPatterns& _sBoard, RXHashTable* _htable, RXBestPosition& bPosition, RXEngineParam& _param)
{
	mutex.lock();


	resume_mutex.lock();
	resume_flag = false;
	resume_mutex.unlock();

	pEngine = _param;

	if(_sBoard.board.hash_code == hash_code_search) {
		//continuation search
		new_search = false;
		
		//timer.start();
		timer.start_tDependent();
		
		set_priority();

		//time for move
		determine_move_time(_sBoard.board);
		
		POSIXThread::yield();
				
		if(time_limit() < get_time_next_level() - (timer.elapsed() - get_start_level())) {
			std::cout << "interruption recherche : " <<  std::endl;
		
			if(process != NULL)
				abortSearch = true;
		}

	} else {
	
		//new position : new search

		set_priority();

		//kill old re-search
		if(process != NULL) {
			abortSearch = true;
			process->join();
			delete process;
			process = NULL;
		}

		new_search = true;
		
		timer.start();
		timer.start_tDependent();
				
		//copie
		sBoardSearch = _sBoard;
		
		hTable = _htable;
		
		//restore Refutation
		if(!hTable->is_shared() && _sBoard.board.n_empties>18)
			hTable->restoreRefutation(sBoardSearch.board);
		
		//affectation answer
		bestPosition = bPosition;
		
		hTable->succ_date(sBoardSearch.board.player);
		hTable->protectPV(sBoardSearch.board);
		
		hTable_shallow->succ_date();
		
		process = new POSIXThread(this);
		process->start();
	}

	if(process != NULL) {
		process->join();
		delete process;
		process = NULL;
	}

	//affectation answer
	bPosition = bestPosition;
	bPosition.tElapsed = timer.elapsed_dependent();
	

	if(sBoardSearch.board.n_empties > 19) {
		int speed = 1;
		if(timer.elapsed() != 0)
			speed = static_cast<int>(bPosition.n_nodes/timer.elapsed());

		std::ostringstream buffer;
		
		std::locale loc(locale(),new My_punct);
		buffer.imbue(loc);
		
		
		buffer	<< showPV(sBoardSearch.board, 6);
		manager->sendMsg(buffer.str());
		
		buffer.str("");
		buffer << "Ts : " << RXTimer::toHMS(timer.elapsed()) << "   Tm : " << RXTimer::toHMS(bPosition.tElapsed);
		manager->sendMsg(buffer.str());
		
		buffer.str("");
		buffer << "nodes : " << setw(14) << bPosition.n_nodes;
		manager->sendMsg(buffer.str());

		buffer.str("");
		buffer << "speed : " << setw(14) << speed << " n/s";
		manager->sendMsg(buffer.str());
	}
	
	*log << "I play " << RXMove::index_to_coord(bPosition.position) << std::endl;
	*log << "evaluation " << (bPosition.score/VALUE_DISC) <<  std::endl;
	*log << "time " << RXTimer::toHMS(bPosition.tElapsed) <<  std::endl;
	
	hash_code_search = 0;

	/**************************************************************************************************/
	/*                                     here one thread only                                       */
	/**************************************************************************************************/

	resume_mutex.lock();
	bool resume = resume_flag;
	resume_mutex.unlock();

	if(!resume && pEngine.search_on_opponent_time == true && _sBoard.board.n_empties>18) {

		pEngine.time_dependent_off();

		//save all Variation
		if(hTable->is_shared())
			hTable->saveAllVariations(_sBoard.board);
	
		RXMove& move = threads[0]._move[sBoardSearch.board.n_empties][1];

		//play best move
		if(bPosition.position == PASS) {
			_sBoard.board.do_pass();
		} else {
			
			((_sBoard.board).*(_sBoard.board.generate_move[bPosition.position]))(move);
			((_sBoard).*(_sBoard.update_patterns[move.position][_sBoard.board.player]))(move);
		
			_sBoard.do_move(move);
			
		}

		//save all refutations
		if(!hTable->is_shared())
			hTable->saveAllRefutations(_sBoard.board);

		sBoardSearch = _sBoard;
		
	
		if(hTable->is_shared()) {
	
			hash_code_search = sBoardSearch.board.hash_code;
		
			timer.start();

			process = new POSIXThread(this);
			process->start();

		} else {

			// unsynchronized acces
			const RXHash* entry = hTable->get(sBoardSearch.board, type_hashtable);
			if(entry != NULL && entry->move != NOMOVE) {
			
				if(entry->move == PASS) {
					sBoardSearch.board.do_pass();
				} else {
					RXMove& answer = threads[0]._move[_sBoard.board.n_empties][1];
					((_sBoard.board).*(_sBoard.board.generate_move[entry->move]))(answer);
					((_sBoard).*(_sBoard.update_patterns[answer.position][_sBoard.board.player]))(answer);
			
					_sBoard.do_move(answer);
					sBoardSearch = _sBoard;
					_sBoard.undo_move(answer);
					
				}

				hash_code_search = sBoardSearch.board.hash_code;
			

				timer.start();

				process = new POSIXThread(this);
				process->start();
			
			} else {
				std::cout << "pas de recherche sur le temps adverse :-(" << std::endl;
				priority = false;
			}
					
		}

		if(bPosition.position == PASS) {
			_sBoard.board.do_pass();
		} else {
			_sBoard.undo_move(move);
		}

	}

	/**************************************************************************************************/
	
	mutex.unlock();
}


void RXEngine::run() {
	
	abortSearch = false;
	
	threads[0].running = true;
	threads[0].stop = false;
	threads[0].idle = false;
	threads[0].workIsWaiting = false;
	
	idle = false;

	*log	<< "------------------------------------------------------------------------------------------------\n"
			<< sBoardSearch
			<< std::endl;
						
	RXBitBoard& board = sBoardSearch.board;

	
	if(hTable->is_shared()) {
		type_hashtable = RXHashTable::HASH_SHARED;
	} else if(board.player == BLACK) {
		type_hashtable = RXHashTable::HASH_BLACK;
	} else { //color white
		type_hashtable = RXHashTable::HASH_WHITE;
	}

	bestPosition.n_nodes = 0;
	board.n_nodes = 0;
	set_time_next_level(0);

	RXMove* list = threads[0]._move[board.n_empties];
	int n_moves = board.moves_producing(list);
	
	if(n_moves == 0) {	//PASS
	
		bestPosition.position = PASS;
		bestPosition.score = 0;
						
	} else if(n_moves == 1) { //FORCED
	
		bestPosition.position = list->next->position;
		bestPosition.score = 0;
		
		
	} else {

		*log << " depth |  score  | principal variation                 | time        |  nodes (N) | speed(N/s) |" << std::endl;

		int depth = sBoardSearch.board.n_empties%2 == BLACK ? 2 : 3;
		int selectivity = MG_SELECT;
		
		RXMove* list1 = list;
		
		//unsynchronized acces
		const RXHash* entry = hTable->get(board, type_hashtable);
		if(entry != NULL) {
	
			bestPosition.position = entry->move;
			list->sort_bestmove(entry->move);
			
			list1 = list->next;
			((sBoardSearch).*(sBoardSearch.update_patterns[list1->position][sBoardSearch.board.player]))(*list1);

			*log << display(board, HASHTABLE) << std::endl;
			if(pEngine.is_time_dependent() && sBoardSearch.board.n_empties> 19 && entry->depth>13)
				manager->sendMsg(showHashmove(board, entry));
												
			if(entry->depth > depth)
				depth = entry->depth;
			
			if(entry->upper == entry->lower) {
				list1->score = entry->upper;
				if(sBoardSearch.board.n_empties - entry->depth <= 0)
					selectivity = min(NO_SELECT, entry->selectivity+1);
				depth+=2;
			} else {
				if(sBoardSearch.board.n_empties - entry->depth <= 0)
					selectivity = entry->selectivity;
					 		
				if(entry->upper == MAX_SCORE)
					list1->score = entry->lower;
				else if(entry->lower == -MAX_SCORE)
					list1->score = entry->upper;
				else
					list1->score = (entry->upper+entry->lower)/2;
			}
					 
			
		}

		for(RXMove* iter = list1->next; iter != NULL; iter = iter->next) {
		
			((sBoardSearch).*(sBoardSearch.update_patterns[iter->position][sBoardSearch.board.player]))(*iter);
			
			sBoardSearch.do_move(*iter);
			if(sBoardSearch.board.n_empties%2 == BLACK)
				iter->score = alphabeta_last_two_ply(0, sBoardSearch, -MAX_SCORE, MAX_SCORE, false);
			else
				iter->score = PVS_last_three_ply(0, sBoardSearch, -MAX_SCORE, MAX_SCORE, false);
			sBoardSearch.undo_move(*iter);
			
		}
		list1->sort_by_score();
		list1->next->score = 0;

				
		bestPosition.position = list->next->position;
		bestPosition.score = list->next->score;

		extra_time_off();
		
		// Wake up sleeping threads:
		wake_sleeping_threads();
		
		for(int i = 1; i < activeThreads; i++)
			assert(thread_is_available(i, 0));
		

		int max_depth = min(sBoardSearch.board.n_empties-10, 33);
		//int max_depth = min(sBoardSearch.board.n_empties-10, 28); //test ggs-1-5.src
			
		if(depth<=max_depth)
			iterative_deepening(sBoardSearch, list, depth, max_depth);

		
		if (sBoardSearch.board.n_empties < 41 && !abortSearch)
			EG_PVS_driver(sBoardSearch, selectivity, list);
		 

	}
	
	/*
	//only for mono core
	if(pEngine.search_on_opponent_time && !pEngine.is_time_dependent())
		manager->flip_Engine();
	*/
		
	timer.stop();
	
	idle = true;
	threads[0].running = false;
	threads[0].stop = true;
	threads[0].idle = true;
	threads[0].workIsWaiting = false;
	
	abortSearch = true;


}

bool RXEngine::probable_timeout(double probable_time_next_level) const {
	
	if(pEngine.is_time_dependent()) {
		
		double tElapsed_dependent = timer.elapsed_dependent();
		double time_for_move = get_time_for_move();
	
		if((tElapsed_dependent + probable_time_next_level) > (time_for_move*2))
			return true;
			
		if(tElapsed_dependent > (time_for_move*0.3))
			if ((tElapsed_dependent + probable_time_next_level) > time_for_move*1.5)
				return true;
	}
	
	return false;
}

double RXEngine::pTime_next_level(RXBitBoard& board, double time_level, int depth, int next_depth) const {

	double probable_Time_next_level;
	
	if(get_type_search() == MIDGAME) {
		if(depth<7 || time_level == 0)
			return 0.0;
			
		double width = max(pow(board.n_nodes, 1.0/depth), 1.85);
		double newNodes = pow(width, next_depth);
		
		probable_Time_next_level = newNodes/(board.n_nodes/time_level);
		if(next_depth>=29)
			probable_Time_next_level *= 3;
			
	} else {	//endgame
	
		switch(CONFIDENCE[get_select_search()]) {
			case 72:
			case 84:
			case 91:
				probable_Time_next_level = time_level * 3;
				break;
				
			case 95:
			case 98:
				probable_Time_next_level = time_level * 5;
				break;
				
			case 99:
			default:
				probable_Time_next_level = time_level * 7;
		}
			
			

	}
			
	return probable_Time_next_level;	
}


void RXEngine::determine_move_time(RXBitBoard& board) {

	double tSafety = min(60.0, (pEngine.tMatch*(20 - min(600.0, pEngine.tMatch)/60))/100.0);
	tSafety = max(6.0, tSafety/max(1, 30 - (board.n_empties + board.n_empties%2)));
		
	
	double tElasped = timer.elapsed_dependent();
	double tRemaining = (pEngine.tRemaining - tSafety) - tElasped;
	double tMove;
	
	if(get_type_search() != ENDGAME && board.n_empties>30) {
		//Midgame mode
		int rMoves = static_cast<int>(floor(((board.n_empties-22)+1)/2.0));
		tMove = ((1+(rMoves-1)/14.0)*tRemaining / rMoves);
		
		if(new_search) {	// new research
			if(pEngine.tMatch == pEngine.tRemaining) // first move
				tMove *= 2.00;
			else
				tMove *= 1.50;
		}
		
	} else {
		//EndGame mode
		int selectivity = get_select_search();
		double confidence = CONFIDENCE[selectivity]/100.0;
		tMove = tRemaining*(confidence*confidence)*0.7;
		if(new_search && selectivity<(NO_SELECT-2)) 	// new research
			tMove *= 1.50;
	}
	
	if(board.n_empties>30)
		tMove = max(2*tMove/3, tSafety/6);
		
	double tExtra = min(tMove, (tRemaining-tMove)/2);
	
	time_mutex.lock();
	time_for_move = tMove + tElasped;
	time_extra_move = tExtra;
	time_mutex.unlock();
	
	tRemaining += tSafety;
	
	std::cout	<< "\n"
				<< "time remaining : " << RXTimer::toHMS(tRemaining) << "\n"
				<< "time Safety    : " << RXTimer::toHMS(tSafety) << "\n"
				<< "time for move  : " << RXTimer::toHMS(tMove) << "\n"
				<< "extra time move: " << RXTimer::toHMS(tExtra) << "\n"
				<< "stop before    : " << RXTimer::toHMS(tRemaining - tMove) << " : " << RXTimer::toHMS(tRemaining - (tMove+tExtra)) <<"\n"
				<< std::endl;

	new_search = false;
}


void RXEngine::writeLog(std::string s) {
		*log << s << std::endl;
}


/// init_threads() is called during startup.  It launches all helper threads,
// and initializes the split point stack and the global locks and condition
// objects.

void RXEngine::init_threads() {
	
	volatile unsigned int i;
	
	pthread_t pthread[1]; //pointeur
	
	for(i = 0; i < THREAD_MAX; i++)
		threads[i].activeSplitPoints = 0;
	
	// All threads except the main thread should be initialized to idle state:
	for(i = 1; i < THREAD_MAX; i++) {
		threads[i].stop = false;
		threads[i].workIsWaiting = false;
		threads[i].idle = true;
		threads[i].running = false;
	}
	

	// Launch the helper threads:
	for(i = 1; i < THREAD_MAX; i++) {
		
		//parameter idle_loop(int threadID, RXSplitPoint* waitSp) function
		idThread = i;
		
		pthread_create(pthread, NULL, init_thread, (void*)(this));
		
		// Wait until the thread has finished launching:
		while(!threads[i].running)
			;
	}
}


// stop_threads() is called when the program exits.  It makes all the
// helper threads exit cleanly.

void RXEngine::stop_threads() {
	
	activeThreads = THREAD_MAX; 	// kill all threads
	idle = false;					// for quit passive waiting
	
	wake_sleeping_threads();
	allThreadsShouldExit = true;
	for(int i = 1; i < THREAD_MAX; i++) {
		threads[i].stop = true;
		while(threads[i].running)
			;
	}
	
}


// idle_loop() is where the threads are parked when they have no work to do.
// The parameter "waitSp", if non-NULL, is a pointer to an active SplitPoint
// object for which the current thread is the master.
// active waiting : infini loop, fast wake up
// passive waiting : condition wake up

void  RXEngine::idle_loop() {
	idle_loop(idThread, NULL);
}

void RXEngine::idle_loop(int threadID, RXSplitPoint* waitSp) {
	
    assert(threadID >= 0 && threadID < THREAD_MAX);
	
    threads[threadID].running = true; 
	
    while(true) {
		
		if(allThreadsShouldExit && threadID != 0)
			break;
		
		// If we are not thinking, wait for a condition to be signaled instead
		// of wasting CPU time polling for work:
		while(threadID != 0 && (idle || threadID >= activeThreads)) {
			MP_wait.lock_mutex();
			if(idle || threadID >= activeThreads)
				MP_wait.wait();
			MP_wait.unlock_mutex();
		}
		
		// If this thread has been assigned work, launch a search:
		
		if(threads[threadID].workIsWaiting) {
			threads[threadID].workIsWaiting = false;
			
			//functions callback
			switch (threads[threadID].splitPoint->CBSearch) {
			 
				
				case RXSplitPoint::MID_PVS:
					MG_SP_search_DEEP(threads[threadID].splitPoint, threadID);
					break;
			 
				case RXSplitPoint::MID_XPROBCUT:
					MG_SP_search_XEndcut(threads[threadID].splitPoint, threadID);
					break;
			 
				case RXSplitPoint::END_PVS:
					EG_SP_search_DEEP(threads[threadID].splitPoint, threadID);
					break;
			 
				case RXSplitPoint::END_XPROBCUT:
					EG_SP_search_XEndcut(threads[threadID].splitPoint, threadID);
					break;
			 }
			 
			threads[threadID].idle = true;
		}
		
		// If this thread is the master of a split point and all threads have
		// finished their work at this split point, return from the idle loop:
		
		// attente active des slaves threads
		if(waitSp != NULL && waitSp->nCpus == 0)
			return;
    }
	
    threads[threadID].running = false;
}

// wake_sleeping_threads() wakes up all sleeping threads (passive waiting) when it is time
// to start a new search from the root (active waiting).

void RXEngine::wake_sleeping_threads() {
    if(activeThreads > 1) {
		for(int i = 1; i < activeThreads; i++) {
			threads[i].idle = true;
			threads[i].workIsWaiting = false;
		}
		
		MP_wait.lock_mutex();
		MP_wait.broadcast();
		MP_wait.unlock_mutex();
		
    }
}

// idle_thread_exists() tries to find an idle thread which is available as
// a slave for the thread with threadID "master".

bool RXEngine::idle_thread_exists(int master) {
	
    assert(master >= 0 && master < activeThreads);
    assert(activeThreads > 1);
	
    for(int i = 0; i < activeThreads; i++)
		if(thread_is_available(i, master))
			return true;
    return false;
}

// thread_is_available() checks whether the thread with threadID "slave" is
// available to help the thread with threadID "master" at a split point.  An
// obvious requirement is that "slave" must be idle.  With more than two
// threads, this is not by itself sufficient:  If "slave" is the master of
// some active split point, it is only available as a slave to the other
// threads which are busy searching the split point at the top of "slave"'s
// split point stack (the "helpful master concept" in YBWC terminology).

bool RXEngine::thread_is_available(int slave, int master) {
	
    assert(slave >= 0 && slave < activeThreads);
    assert(master >= 0 && master < activeThreads);
    assert(activeThreads > 1);
	
    if(!threads[slave].idle || slave == master)
		return false;
	
    if(threads[slave].activeSplitPoints == 0)
		// No active split points means that the thread is available as a slave
		// for any other thread.
		return true;
	
    //the "helpful master concept" in YBWC terminology
    if(activeThreads == 2)
		return true;
	
    // Apply the "helpful master" concept if possible.
	if(threads[slave].splitPointStack[threads[slave].activeSplitPoints-1].slaves[master])
    //if(splitPointStack[slave][threads[slave].activeSplitPoints-1].slaves[master])
		return true;
	
    return false;
}



// split() does the actual work of distributing the work at a node between
// several threads.  If it does not succeed in splitting the node (because no
// idle threads are available, or because we have no unused split point
// objects), the function immediately returns false.  If splitting is
// possible, a SplitPoint object is initialized with all the data that must
// be copied to the helper threads (the current position and,
// alpha, beta, the search depth, etc.), and we tell our helper threads that
// they have been assigned work.  This will cause them to instantly leave
// their idle loops and call sp_search().  When all threads have returned
// from sp_search (or, equivalently, when splitPoint->cpus becomes 0),
// split() returns true.


bool RXEngine::split(RXBBPatterns& sBoard, bool pv,
					int depth, int selectivity, bool* selective_cutoff, bool* child_selective_cutoff,
					int* alpha, int* beta, int* bestScore, int* bestMove,
					RXMove* list, int master, RXSplitPoint::t_callBackSearch callback) {
	
	
	assert(*bestScore >= -MAX_SCORE); // && *bestScore <= *alpha);	possible in aspiration window
	assert(*alpha < *beta);
	assert(*beta <= MAX_SCORE);

	assert(master >= 0 && master < activeThreads);
	assert(activeThreads > 1);
	
	MP_sync.lock();
		

	// If no other thread is available to help us, or if we have too many
	// active split points, don't split:
	if(!idle_thread_exists(master) || threads[master].activeSplitPoints >= ACTIVE_SPLITPOINT_MAX) {
		MP_sync.unlock();
		return false;
	}
		
	// Pick the next available split point object from the split point stack:
	RXSplitPoint& splitPoint = threads[master].splitPointStack[threads[master].activeSplitPoints];
	
	threads[master].activeSplitPoints++;

	// Initialize the split point object:
	splitPoint.parent = threads[master].splitPoint;
	splitPoint.finished = false;

	splitPoint.sBoard = &sBoard; // pointer on sBoard
	
	splitPoint.depth = depth;
	splitPoint.pv = pv;
	splitPoint.selectivity = selectivity;

	splitPoint.selective_cutoff = *selective_cutoff;
	splitPoint.child_selective_cutoff = *child_selective_cutoff;
	splitPoint.alpha = *alpha;
	splitPoint.beta = *beta;
	splitPoint.bestScore = *bestScore;
	splitPoint.bestMove = *bestMove;

	splitPoint.list = list;

	splitPoint.CBSearch = callback;

	splitPoint.master = master;
	splitPoint.nCpus = 1;

	for(int i = 0; i < activeThreads; i++)
		splitPoint.slaves[i] = 0;

	threads[master].splitPoint = &splitPoint;
	

	// Make copies of the current position and search stack for each thread:
	for(int i = 0; i < activeThreads && splitPoint.nCpus < THREAD_PER_SPLITPOINT_MAX; i++)
	if(thread_is_available(i, master)) {
		threads[i].splitPoint = &splitPoint;
		splitPoint.slaves[i] = 1;
		splitPoint.nCpus++;
	}
	

	// Tell the threads that they have work to do.  This will make them leave
	// their idle loop.
	for(int i = 0; i < activeThreads; i++)
	if(i == master || splitPoint.slaves[i]) {
		threads[i].workIsWaiting = true;
		threads[i].idle = false;
		threads[i].stop = false;
	}

	MP_sync.unlock();

	// Everything is set up.  The master thread enters the idle loop, from
	// which it will instantly launch a search, because its workIsWaiting
	// slot is 'true'.  We send the split point as a second parameter to the
	// idle loop, which means that the main thread will return from the idle
	// loop when all threads have finished their work at this split point
	// (i.e. when // splitPoint->nCpus == 0).
	idle_loop(master, &splitPoint);

	// We have returned from the idle loop, which means that all threads are
	// finished.  Update alpha, beta and bestvalue, and return:
	MP_sync.lock();

	*alpha = splitPoint.alpha;
	*beta = splitPoint.beta;
	*bestScore = splitPoint.bestScore;
	*bestMove = splitPoint.bestMove;
	*selective_cutoff = splitPoint.selective_cutoff;
	*child_selective_cutoff = splitPoint.child_selective_cutoff;

	threads[master].stop = false;
	threads[master].idle = false;
	threads[master].activeSplitPoints--;
	
	threads[master].splitPoint = splitPoint.parent;

	MP_sync.unlock();
	 
	 

	return true;
}

